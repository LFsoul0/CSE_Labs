#include <iostream>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>

#include <mutex>
#include <string>
#include <vector>
#include <map>
#include <cctype>
#include <algorithm>

#include "rpc.h"
#include "mr_protocol.h"

using namespace std;

struct KeyVal {
	string key;
	string val;

	KeyVal() {}
	KeyVal(string key, string val) : key(key), val(val) {}
};

//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
vector<KeyVal> Map(const string &filename, const string &content)
{
	vector<KeyVal> words;
	size_t len = content.length();
	size_t start = 0;
	for (size_t i = 0; i < len; ++i) {
		if (!isalpha(content[i])) {
			if (start == i) {
				++start;
			}
			else {
				words.push_back(KeyVal(content.substr(start, i - start), "1"));
				start = i + 1;
			}
		}
	}
	if (start != len) {
		words.push_back(KeyVal(content.substr(start, len - start), "1"));
	}

	return words;
}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
string Reduce(const string &key, const vector < string > &values)
{
	return to_string(values.size());
}


typedef vector<KeyVal> (*MAPF)(const string &key, const string &value);
typedef string (*REDUCEF)(const string &key, const vector<string> &values);

class Worker {
public:
	Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf);

	void doWork();

private:
	void doMap(int index, const vector<string> &filenames);
	void doReduce(int index);
	void doSubmit(mr_tasktype taskType, int index);

	mutex mtx;
	int id;

	rpcc *cl;
	std::string basedir;
	MAPF mapf;
	REDUCEF reducef;
};


Worker::Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf)
{
	this->basedir = dir;
	this->mapf = mf;
	this->reducef = rf;

	sockaddr_in dstsock;
	make_sockaddr(dst.c_str(), &dstsock);
	this->cl = new rpcc(dstsock);
	if (this->cl->bind() < 0) {
		printf("mr worker: call bind error\n");
	}
}

void Worker::doMap(int index, const vector<string> &filenames)
{
	string filename = filenames.back();
	string content;

	getline(ifstream(filename), content, '\0');
	vector<KeyVal> KVA = mapf(filename, content);

	stringstream ss[REDUCER_COUNT];
	for (KeyVal& kv : KVA) {
		unsigned long hash = 0;
		for (char& c : kv.key) {
			hash = hash + c;
		}
		hash = hash % REDUCER_COUNT;

		ss[hash] << kv.key.data() << '\n';
	}

	ofstream ofs;
	for (int i = 0; i < REDUCER_COUNT; ++i) {
		ofs.open("mr-" + to_string(index) + "-" + to_string(i), ios_base::trunc);
		ofs << ss[i].str();
		ofs.close();
	}
}

void Worker::doReduce(int index)
{
	vector <KeyVal> intermediate;

	ifstream ifs;
	for (unsigned int i = 0;; ++i) {
		string content;
		KeyVal kv("", "1");

		ifs.open("mr-" + to_string(i) + "-" + to_string(index));
		if (!ifs.is_open()) break;

		getline(ifs, content, '\0');
		istringstream ss(content);
		while (getline(ss, kv.key, '\n')) {
			intermediate.push_back(kv);
		}

		ifs.close();
	}

	sort(intermediate.begin(), intermediate.end(),
		[](KeyVal const& a, KeyVal const& b) {
			return a.key < b.key;
		});

	stringstream ss;
	unsigned int size = intermediate.size();
	for (unsigned int i = 0; i < size;) {
		string key = intermediate[i].key;
		vector<string> values;

		for (; i < size && intermediate[i].key == key; ++i) {
			values.push_back(intermediate[i].val);
		}

		string output = Reduce(key, values);
		ss << key.data() << ' ' << output.data() << '\n';
	}

	ofstream ofs;
	ofs.open("mr-out-" + to_string(index));
	ofs << ss.str();
	ofs.close();
}

void Worker::doSubmit(mr_tasktype taskType, int index)
{
	bool b;
	mr_protocol::status ret = this->cl->call(mr_protocol::submittask, taskType, index, b);
	if (ret != mr_protocol::OK) {
		fprintf(stderr, "submit task failed\n");
		exit(-1);
	}
}

void Worker::doWork()
{
	mr_protocol::AskTaskResponse response;
	mr_protocol::status ret;
	vector<string> filenames;

	for (;;) {
		ret = cl->call(mr_protocol::asktask, 0, response);
		if (ret == mr_protocol::OK) {
			if (response.taskType == mr_tasktype::MAP) {
				filenames.push_back(response.filename);
				doMap(response.index, filenames);
				doSubmit(response.taskType, response.index);
			}
			else if (response.taskType == mr_tasktype::REDUCE) {
				doReduce(response.index);
				doSubmit(response.taskType, response.index);
			}
			else {
				sleep(1);
			}
		}
	}
}

int main(int argc, char **argv)
{
	if (argc != 3) {
		fprintf(stderr, "Usage: %s <coordinator_listen_port> <intermediate_file_dir> \n", argv[0]);
		exit(1);
	}

	MAPF mf = Map;
	REDUCEF rf = Reduce;
	
	Worker w(argv[1], argv[2], mf, rf);
	w.doWork();

	return 0;
}

